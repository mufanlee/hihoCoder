# hiho密码

_**难度: Lv.1**_

## _[问题](http://hihocoder.com/problemset/problem/1283)_
时间限制:10000ms

单点时限:1000ms

内存限制:256MB

**描述**

小Ho根据最近在密码学课上学习到的知识，开发出了一款hiho密码，这款密码的秘钥是这样生成的：对于一种有N个字母的语言，选择一个长度为M的单词；将组成这个单词的所有字母按照顺序不重复的写出（即遇到相同字母时跳过）；然后将字母表剩下的没有使用过的字母按照顺序在其后进行排列。

如对于有5个字母的hiho语，选择单词1, 2, 2, 4, 3（此处数字表示字母在字母表中的顺序），则秘钥为1,2,4,3,5。

但是有一天小Ho在计算出了秘钥之后，却发现他弄丢了一开始选择的单词，于是他找到了你，希望你能够帮他找到能够生成这个秘钥的最短的单词。

**输入**

每个输入文件包含单组测试数据。

每组测试数据的第一行为一个正整数N，意义如前文所述。

每组测试数据的第二行为N个正整数，用来描述一个秘钥，其中第i个正整数Ai表示秘钥的第i个字符在字母表中的顺序。

对于100%的数据，满足N<=1000，1<=Ai<=N。

对于100%的数据，满足对于任意1<=i, j<=N，若i≠j，则Ai≠Aj。

**输出**

对于每组测试数据，输出能够生成输入给出的秘钥的最短的单词（空串不认为是单词）。由于字母表没有给出，所以对于每个字母，输出其在字母表中的顺序即可（用空格隔开）。

**样例输入**
```
5
1 2 4 3 5
```
**样例输出**
```
1 2 4
```

## 思路

> 见注释

## 代码
```java
import java.util.Scanner;

/**
 * 思路：首先是从单词中获取不重复的字母，再讲语言中剩下的字母按照顺序加进去，因而后面的字母是有顺序的，即从小到大。
 * 要找最短的单词，即找密钥中后半部分最长的从小到大排序的字母。
 * 要注意特殊情况：（空串不认为是单词）
 * n = 0，输出空；
 * n = 1，输出1；
 * 密钥中的所有字母都有序，输出第一个字母。
 */
public class Main {
    public static void main(String []args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if(n == 0) System.out.println();
        else {
            int []pwd = new int[n];
            for (int i = 0; i < n; i++)
                pwd[i] = sc.nextInt();
            int i = n-1;
            for (; i > 0; i--)
            {
                if(pwd[i] < pwd[i-1])
                    break;
            }
            if(i == 0)
            {
                System.out.println(pwd[0]);
            }
            else {
                for (int j = 0; j < i-1; j++)
                    System.out.print(pwd[j] + " ");
                System.out.println(pwd[i-1]);
            }
        }
    }
}
```